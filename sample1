@csrf_exempt
def stream_job_events(request, job_id):
    def event_stream():
        base_url = get_aap_base_url()  # From previous solution
        events_url = f"{base_url}/api/v2/jobs/{job_id}/job_events/"
        job_url = f"{base_url}/api/v2/jobs/{job_id}/"
        headers = {"Authorization": f"Bearer {settings.AAP_TOKEN}"}
        
        try:
            last_seen_event = None
            seen_events = set()
            job_completed = False
            
            while not job_completed:
                # Check job status first
                job_response = requests.get(
                    job_url,
                    headers=headers,
                    verify=True,
                    timeout=10
                )
                job_data = job_response.json()
                current_status = job_data.get('status')
                
                # Handle all possible statuses
                if current_status in ['successful', 'failed', 'error', 'canceled']:
                    yield f"data: {json.dumps({
                        'type': 'job_status',
                        'status': 'complete',
                        'job_status': current_status,
                        'final_event': last_seen_event
                    })}\n\n"
                    job_completed = True
                    break
                elif current_status == 'running':
                    # Get new events only if job is still running
                    events_response = requests.get(
                        events_url,
                        headers=headers,
                        verify=True,
                        timeout=10
                    )
                    events_data = events_response.json()
                    
                    # Process new events
                    for event in events_data.get('results', []):
                        event_id = event.get('id')
                        if event_id not in seen_events:
                            seen_events.add(event_id)
                            last_seen_event = event
                            yield f"data: {json.dumps({
                                'type': 'job_event',
                                'event_data': {
                                    'event': event.get('event'),
                                    'task': event.get('task'),
                                    'host': event.get('host', {}).get('name'),
                                    'stdout': event.get('stdout'),
                                    'counter': event.get('counter'),
                                    'timestamp': event.get('created')
                                }
                            })}\n\n"
                    
                    # Handle pagination
                    events_url = events_data.get('next', events_url)
                    
                    # If no new events, wait before polling again
                    if not events_data.get('results'):
                        time.sleep(2)  # Polling interval
                else:
                    # Handle unexpected statuses
                    yield f"data: {json.dumps({
                        'type': 'job_status',
                        'status': 'unknown',
                        'job_status': current_status,
                        'message': f'Unexpected job status: {current_status}'
                    })}\n\n"
                    break
                    
        except requests.exceptions.RequestException as e:
            yield f"data: {json.dumps({
                'type': 'error',
                'error': f'API request failed: {str(e)}'
            })}\n\n"
        except Exception as e:
            yield f"data: {json.dumps({
                'type': 'error',
                'error': f'Unexpected error: {str(e)}'
            })}\n\n"

    return StreamingHttpResponse(
        event_stream(),
        content_type="text/event-stream"
    )
