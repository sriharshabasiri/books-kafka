# api/views.py
import os
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.decorators import api_view
from ansible_runner import run

@csrf_exempt
@api_view(['POST'])
def search_logs(request):
    try:
        # Get parameters from frontend
        uuid = request.data.get('uuid')
        search_date = request.data.get('search_date')
        environment = request.data.get('environment', 'dev')
        
        # Validate inputs
        if not uuid or not search_date:
            return JsonResponse({'error': 'UUID and search_date are required'}, status=400)

        # Prepare extra vars for Ansible
        extra_vars = {
            'uuid': uuid,
            'search_date': search_date,
            'main_log_path': f'/opt/finacle/{environment}/common/log/',
            'error_log_paths': [
                f'/opt/finacle/{environment}/common/log/finint/fcrmmb',
                f'/opt/finacle/{environment}/common/log/fsb/fsbwebservice'
            ]
        }

        # Run Ansible playbook
        result = run(
            playbook='log_search.yml',
            extravars=extra_vars,
            quiet=True
        )

        # Process results
        if result.status == "successful":
            # Parse Ansible output to extract the relevant information
            output = parse_ansible_output(result)
            return JsonResponse(output)
        else:
            return JsonResponse({'error': 'Ansible playbook failed', 'details': result.stderr}, status=500)

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

def parse_ansible_output(result):
    """Parse Ansible runner output to extract success/failure results"""
    output = {'status': 'not_found'}
    
    for event in result.events:
        if event['event'] == 'runner_on_ok':
            event_data = event['event_data']
            # Check for success results
            if 'SUCCESSFUL TRANSACTIONS' in event_data.get('res', {}).get('msg', ''):
                output.update({
                    'status': 'success',
                    'results': event_data['res']['msg'].split('\n')[1:]  # Skip header line
                })
            # Check for failure results
            elif 'FAILURE LINES' in event_data.get('res', {}).get('msg', ''):
                output.update({
                    'status': 'failure',
                    'results': event_data['res']['msg'].split('\n')[1:]  # Skip header line
                })
            # Check for error context
            elif 'ERROR CONTEXT' in event_data.get('res', {}).get('msg', ''):
                output['error_context'] = event_data['res']['msg'].split('\n')[1:]  # Skip header line
    
    return output





# urls.py
from django.urls import path
from .views import search_logs

urlpatterns = [
    path('api/search-logs/', search_logs, name='search-logs'),
]


// LogSearch.jsx
import React, { useState } from 'react';
import axios from 'axios';

const LogSearch = () => {
  const [uuid, setUuid] = useState('');
  const [searchDate, setSearchDate] = useState('');
  const [environment, setEnvironment] = useState('dev');
  const [results, setResults] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.post('/api/search-logs/', {
        uuid,
        search_date: searchDate,
        environment
      });
      
      setResults(response.data);
    } catch (err) {
      setError(err.response?.data?.error || 'Failed to search logs');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="log-search-container">
      <h2>Log Search</h2>
      
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label>UUID:</label>
          <input 
            type="text" 
            value={uuid} 
            onChange={(e) => setUuid(e.target.value)} 
            required 
          />
        </div>
        
        <div className="form-group">
          <label>Date (DDMonYYYY):</label>
          <input 
            type="text" 
            value={searchDate} 
            onChange={(e) => setSearchDate(e.target.value)}
            placeholder="e.g., 10Mar2025"
            required 
          />
        </div>
        
        <div className="form-group">
          <label>Environment:</label>
          <select value={environment} onChange={(e) => setEnvironment(e.target.value)}>
            <option value="dev">Development</option>
            <option value="prod">Production</option>
          </select>
        </div>
        
        <button type="submit" disabled={loading}>
          {loading ? 'Searching...' : 'Search Logs'}
        </button>
      </form>
      
      {error && <div className="error-message">{error}</div>}
      
      {results && (
        <div className="results-container">
          {results.status === 'success' && (
            <div className="success-results">
              <h3>Successful Transactions</h3>
              <pre>{results.results.join('\n')}</pre>
            </div>
          )}
          
          {results.status === 'failure' && (
            <div className="failure-results">
              <h3>Failure Details</h3>
              <pre>{results.results.join('\n')}</pre>
              
              {results.error_context && (
                <>
                  <h3>Error Context</h3>
                  <pre>{results.error_context.join('\n')}</pre>
                </>
              )}
            </div>
          )}
          
          {results.status === 'not_found' && (
            <div className="no-results">
              No matching entries found for UUID {uuid} on date {searchDate}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default LogSearch;
