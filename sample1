# middleware.py
import json
import time
from django.utils.deprecation import MiddlewareMixin
from django.http import StreamingHttpResponse

class RequestResponseLoggerMiddleware(MiddlewareMixin):
    def process_request(self, request):
        request._logging_start_time = time.time()
        self._log_request(request)
        return None

    def process_response(self, request, response):
        response_time = time.time() - request._logging_start_time
        
        # Handle StreamingHttpResponse differently
        if isinstance(response, StreamingHttpResponse):
            self._log_streaming_response(request, response, response_time)
            return response
        
        # Regular response handling
        self._log_regular_response(request, response, response_time)
        return response

    def _log_request(self, request):
        """Log request details safely"""
        request_info = {
            'method': request.method,
            'path': request.path,
            'query_params': dict(request.GET),
            'headers': {k: v for k, v in request.headers.items()},
        }

        if request.method in ('POST', 'PUT', 'PATCH'):
            try:
                request_info['body'] = json.loads(request.body.decode('utf-8'))
            except (UnicodeDecodeError, json.JSONDecodeError, AttributeError):
                request_info['body'] = "(unreadable or non-JSON data)"

        print(f"\n[Request] {json.dumps(request_info, indent=2)}")

    def _log_regular_response(self, request, response, response_time):
        """Log regular responses"""
        log_data = {
            'status': response.status_code,
            'time': f"{response_time:.3f}s",
            'headers': dict(response.headers),
        }

        try:
            if hasattr(response, 'content'):
                log_data['content'] = json.loads(response.content.decode('utf-8'))
        except (UnicodeDecodeError, json.JSONDecodeError):
            log_data['content'] = "(binary or non-JSON data)"

        print(f"[Response] {json.dumps(log_data, indent=2)}")

    def _log_streaming_response(self, request, response, response_time):
        """Log streaming responses"""
        log_data = {
            'status': response.status_code,
            'time': f"{response_time:.3f}s",
            'headers': dict(response.headers),
            'type': 'streaming',
            'content_type': response.get('Content-Type', ''),
        }
        print(f"[Streaming Response] {json.dumps(log_data, indent=2)}")

        # Optionally wrap the streaming content to log chunks
        if not hasattr(response, '_already_wrapped'):
            original_stream = response.streaming_content
            response.streaming_content = self._wrap_stream(original_stream)
            response._already_wrapped = True
        return response

    def _wrap_stream(self, stream):
        """Wrap streaming content to log chunks"""
        for chunk in stream:
            try:
                if isinstance(chunk, bytes):
                    chunk_str = chunk.decode('utf-8')
                else:
                    chunk_str = str(chunk)
                print(f"[Streaming Chunk] {chunk_str[:200]}...")  # Log first 200 chars
            except Exception as e:
                print(f"[Streaming Error] {str(e)}")
            yield chunk
